# -*- coding: utf-8 -*-
# pylint: disable=wrong-import-position, too-many-instance-attributes, too-many-locals, line-too-long

"""
Classes for reading and getting info from Retro tables.
"""

from __future__ import absolute_import, division, print_function

__all__ = '''
    MACHINE_EPS
    MY_CLSIM_TABLE_KEYS
    TABLE_NORM_KEYS
    open_table_file
    get_table_norm
    generate_time_indep_table
    load_clsim_table_minimal
    load_clsim_table
    load_t_r_theta_table
    generate_pexp_5d_function
    pexp_t_r_theta
    pexp_xyz
    CLSimTable
    CLSimTables
    DOMTimePolarTables
    TDICartTable
'''.split()

__author__ = 'P. Eller, J.L. Lanfranchi'
__license__ = '''Copyright 2017 Philipp Eller and Justin L. Lanfranchi

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.'''

from collections import OrderedDict
from copy import deepcopy
from glob import glob
from os import remove
from os.path import abspath, basename, dirname, isdir, isfile, join, splitext
from StringIO import StringIO
from subprocess import Popen, PIPE
import sys
from time import time
import math

import numpy as np

from pisa.utils.format import hrlist2list

if __name__ == '__main__' and __package__ is None:
    RETRO_DIR = dirname(dirname(abspath(__file__)))
    if RETRO_DIR not in sys.path:
        sys.path.append(RETRO_DIR)
import retro
from retro import PI, TWO_PI
from retro.ckv import survival_prob_from_cone, survival_prob_from_smeared_cone
from retro.generate_t_r_theta_table import generate_t_r_theta_table


# TODO: remove this class!
class CLSimTable(object):
    """Load and use information from a single "raw" individual-DOM
    (time, r, theta, thetadir, deltaphidir)-binned Retro table.

    Note that this is the table generated by CLSim, prior to any manipulations
    performed for using the table with Retro.

    Parameters
    ----------
    tables_dir : string

    hash_val : None or string
        Hash string identifying the source Retro tables to use.

    string : int
        Indexed from 1

    depth_idx : int

    angular_acceptance_fract : float
        Normalization for angular acceptance being less than 1

    naming_version : int or None
        Version of naming for CLSim table (original is 0). Passing None uses
        the latest version. Note that any derived tables use the latest naming
        version regardless of what is passed here.

    """
    def __init__(self, fpath=None, tables_dir=None, hash_val=None, string=None,
                 depth_idx=None, seed=None,
                 angular_acceptance_fract=0.338019664877, naming_version=None):

        print('WARNING: This class is deprecated and will be removed soon!')

        # Translation and validation of args
        assert 0 < angular_acceptance_fract <= 1
        self.angular_acceptance_fract = angular_acceptance_fract

        if naming_version is None:
            naming_version = len(retro.CLSIM_TABLE_FNAME_PROTO) - 1
        fname_proto = retro.CLSIM_TABLE_FNAME_PROTO[naming_version]

        if fpath is None:
            tables_dir = retro.expand(tables_dir)
            assert isdir(tables_dir)
            self.tables_dir = tables_dir
            self.hash_val = hash_val
            self.seed = seed

            if isinstance(string, basestring):
                self.string = string.strip().lower()
                assert self.string in ('ic', 'dc')
                self.subdet = self.string
                self.string_idx = None

            else:
                self.string = string
                self.string_idx = self.string - 1

                if self.string_idx < 79:
                    self.subdet = 'ic'
                else:
                    self.subdet = 'dc'

            self.depth_idx = depth_idx

            fname = fname_proto.format(
                hash_val=hash_val,
                string=self.string,
                depth_idx=self.depth_idx,
                seed=self.seed
            )
            self.fpath = join(self.tables_dir, fname)

        else:
            assert tables_dir is None
            assert hash_val is None
            assert string is None
            assert depth_idx is None

            self.fpath = fpath
            self.tables_dir = dirname(fpath)
            info = retro.interpret_clsim_table_fname(fpath)
            self.string = info['string']
            if isinstance(self.string, int):
                self.string_idx = self.string - 1
            else:
                self.string_idx = None
            self.hash_val = info['hash_val']
            self.depth_idx = info['depth_idx']
            self.seed = info['seed']

        assert self.subdet in ('ic', 'dc')
        if self.subdet == 'ic':
            self.quantum_efficiency = retro.IC_DOM_QUANT_EFF
        elif self.subdet == 'dc':
            self.quantum_efficiency = retro.DC_DOM_QUANT_EFF

        self.dtp_fname_proto = retro.RETRO_DOM_TABLE_FNAME_PROTO[-1]

        table_info = load_clsim_table(
            self.fpath, step_length=1,
            angular_acceptance_fract=self.angular_acceptance_fract,
            quantum_efficiency=self.quantum_efficiency
        )

        self.table = table_info.pop('table')
        self.table_shape = table_info.pop('table_shape')
        self.n_dims = len(self.table_shape)
        self.n_photons = table_info.pop('n_photons')
        self.phase_refractive_index = table_info.pop('phase_refractive_index')
        self.angular_acceptance_fract = angular_acceptance_fract

        self.r_bin_edges = table_info.pop('r_bin_edges')
        self.t_bin_edges = table_info.pop('t_bin_edges')
        self.costheta_bin_edges = table_info.pop('costheta_bin_edges')

        self.theta_bin_edges = np.arccos(self.costheta_bin_edges) # radians
        self.costheta_centers = retro.linear_bin_centers(self.costheta_bin_edges)
        self.theta_centers = np.arccos(self.costheta_centers) # radians

        t_bin_widths = np.diff(self.t_bin_edges)
        assert np.allclose(t_bin_widths, t_bin_widths[0])
        self.t_bin_width = np.mean(t_bin_widths)

        if self.n_dims == 5:
            self.costhetadir_bin_edges = table_info.pop('costhetadir_bin_edges')
            self.deltaphidir_bin_edges = table_info.pop('deltaphidir_bin_edges') # rad
            self.costhetadir_centers = retro.linear_bin_centers(self.costhetadir_bin_edges)
            self.thetadir_bin_edges = np.arccos(self.costhetadir_bin_edges) # rad
            self.thetadir_centers = np.arccos(self.costhetadir_centers) # rad
            self.deltaphidir_centers = retro.linear_bin_centers(self.deltaphidir_bin_edges) # rad
        else:
            raise NotImplementedError(
                'Can only work with CLSim tables with 5 dimensions; got %d'
                % self.n_dims
            )

        self.table_norm = table_info.pop('table_norm')

        del table_info

        #self.norm = (
        #    1
        #    / self.n_photons
        #    / (retro.SPEED_OF_LIGHT_M_PER_NS / self.phase_refractive_index
        #       * self.t_bin_width)
        #    * self.angular_acceptance_fract
        #    * (len(self.costheta_bin_edges) - 1)
        #)

        # The photon direction is tabulated in dimensions 3 and 4
        #self.survival_prob = self.data.sum(axis=(3, 4)) * self.table_norm

    def export_t_r_theta_table(self, outdir=None, overwrite=True):
        """Distill binned photon directionality information into a single
        vector per bin and force azimuthal symmetry to reduce the table from a
        5D histogram of photon counts binned in
        (t, r, costheta, phi, thetadir, deltaphidir) to a 3D histogram binned in
        (t, r, costheta) where each bin contains a probability and an average
        direction vector.

        The resulting file will be placed in the same directory as the source
        table and the file name will be the source filename suffixed by
        "_r_cz_t_angles" (prior to the extension).

        Parameters
        ----------
        outdir : string, optional
            If specified, store the DOM-time-polar table into this directory.
            Otherwise, if not specified, the table is stored in the same
            directory as the source table.

        """
        import pyfits

        if outdir is None:
            outdir = self.tables_dir
        outdir = retro.expand(outdir)

        new_fname = self.dtp_fname_proto.format(depth_idx=self.depth_idx)
        new_fpath = join(outdir, new_fname)

        if not isdir(outdir):
            retro.mkdir(outdir)

        if isfile(new_fpath):
            if overwrite:
                retro.wstderr('WARNING: overwriting existing file at "%s"\n' % new_fpath)
                remove(new_fpath)
            else:
                retro.wstderr(
                    'ERROR: There is an existing file at "%s"; not'
                    ' proceeding.\n' % new_fpath
                )
                return

        survival_probs, average_thetas, average_phis, lengths = \
            generate_t_r_theta_table(
                table=self.table,
                n_photons=self.n_photons,
                phase_refractive_index=self.phase_refractive_index,
                t_bin_width=self.t_bin_width,
                angular_acceptance_fract=self.angular_acceptance_fract,
                thetadir_centers=self.thetadir_centers,
                deltaphidir_centers=self.deltaphidir_centers,
                theta_bin_edges=self.theta_bin_edges
            )
        objects = [
            pyfits.PrimaryHDU(survival_probs),
            pyfits.ImageHDU(average_thetas.astype(np.float32)),
            pyfits.ImageHDU(average_phis.astype(np.float32)),
            pyfits.ImageHDU(lengths.astype(np.float32)),
            pyfits.ImageHDU(self.t_bin_edges.astype(np.float32)),
            pyfits.ImageHDU(self.r_bin_edges.astype(np.float32)),
            pyfits.ImageHDU(self.theta_bin_edges[::-1].astype(np.float32))
        ]

        hdulist = pyfits.HDUList(objects)
        hdulist.writeto(new_fpath)
